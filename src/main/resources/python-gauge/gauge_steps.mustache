# coding: utf-8

{{>partial_header}}

import enum
import json
import uuid
import os
import {{packageName}}
from typing import TypeVar, List
from getgauge.python import step, before_scenario, Messages

{{#apiInfo.apis}}
from {{apiPackage}}.{{classFilename}} import {{classname}}
{{/apiInfo.apis}}

T = TypeVar('T')

class TestContext:
    def __init__(self):
        target_host = os.getenv("GAUGE_TARGET_HOST", "{{gaugeTargetHost}}")

        if not target_host:
            raise ValueError("TARGET_HOST is not set or still set to the default placeholder. Please set the GAUGE_TARGET_HOST environment variable or pass -p gaugeTargetHost=... during generation.")

        configuration = PetStore.Configuration(host=target_host)
        self.api_client = PetStore.ApiClient(configuration)
        self.request = None
        self.response = None

test_context = TestContext()
@step("Create a <operationId> request for the <classname>")
def create_a_request_for_the_api(operation_id, classname):
    test_context.request = Request(classname, operation_id)

@step("Create an <operationId> request for the <classname>")
def create_an_request_for_the_api(operation_id, classname):
    test_context.request = Request(classname, operation_id)

@step("Give the <parameter> parameter a value of <value>")
def give_the_parameter_a_value_of(parameter, value):
    request = test_context.request

    {{#apiInfo.apis}}
    if request.classname == "{{#lambda.pascalcase}}{{classname}}{{/lambda.pascalcase}}":
        {{#operations}}
        {{#operation}}
        if request.operation_id == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}":
            {{#allParams}}
            if parameter == "{{#lambda.camelcase}}{{paramName}}{{/lambda.camelcase}}":
                request.parameters["{{paramName}}"] = convert_to({{{dataType}}}, value)
                return
            {{/allParams}}
        {{/operation}}
        {{/operations}}
    {{/apiInfo.apis}}

    raise ValueError(f"{request.classname}.{request.operation_id} does not have a parameter called {parameter}")

@step("Give the <parameter> parameter a JSON value of <value>")
def give_the_parameter_a_json_value_of(parameter, value):
    request = test_context.request

    {{#apiInfo.apis}}
    if request.classname == "{{#lambda.pascalcase}}{{classname}}{{/lambda.pascalcase}}":
        {{#operations}}
        {{#operation}}
        if request.operation_id == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}":
            {{#allParams}}
            if parameter == "{{#lambda.camelcase}}{{paramName}}{{/lambda.camelcase}}":
                {{#isModel}}
                request.parameters[parameter] = {{modelPackage}}.{{{dataType}}}.from_json(value)
                return
                {{/isModel}}
                {{^isModel}}
                raise TypeError("Cannot deserialize a JSON string to {{{dataType}}}")
                {{/isModel}}
            {{/allParams}}
        {{/operation}}
        {{/operations}}
    {{/apiInfo.apis}}

    raise ValueError(f"{request.classname}.{request.operation_id} does not have a parameter called {parameter}")

@step("Give the <parameter> parameter the following values: <table>")
def give_the_parameter_the_following_values(parameter, table):
    request = test_context.request
    
    {{#apiInfo.apis}}
    if request.classname == "{{#lambda.pascalcase}}{{classname}}{{/lambda.pascalcase}}":
        {{#operations}}
        {{#operation}}
        if request.operation_id == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}":
            {{#allParams}}
            if parameter == "{{#lambda.camelcase}}{{paramName}}{{/lambda.camelcase}}":
                {{#isContainer}}
                collection = list[{{{baseType}}}]()
                for row in table:
                    collection.append(convert_to({{{baseType}}}, row[0]))
                request.parameters["{{paramName}}"] = collection
                return
                {{/isContainer}}
                {{^isContainer}}
                raise TypeError("Cannot read a DataTable into parameter {{#lambda.camelcase}}{{paramName}}{{/lambda.camelcase}} as it is not an array")
                {{/isContainer}}
            {{/allParams}}
        {{/operation}}
        {{/operations}}
    {{/apiInfo.apis}}

    raise ValueError(f"{request.classname}.{request.operation_id} does not have a parameter called {parameter}")

@step("Send the request")
def send_the_request():
    request = test_context.request
    
    {{#apiInfo.apis}}
    if request.classname == "{{#lambda.pascalcase}}{{classname}}{{/lambda.pascalcase}}":
        api = {{classname}}(test_context.api_client)

        {{#operations}}
        {{#operation}}
        if request.operation_id == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}":
            test_context.response = api.{{operationId}}_with_http_info({{#allParams}}request.parameters.get("{{#lambda.camelcase}}{{paramName}}{{/lambda.camelcase}}"){{^-last}}, {{/-last}}{{/allParams}})
        {{/operation}}
        {{/operations}}
    {{/apiInfo.apis}}

@step("The response status should be <statusCode>")
def the_response_status_should_be(status_code):
    assert test_context.response.status_code == int(status_code)

@step("The response content should be <content>")
def the_response_content_should_be(content):
    content_type = ""
    if test_context.response.headers is not None:
        headers_lower = {k.lower(): v for k, v in test_context.response.headers.items()}
        content_type = headers_lower.get("content-type", "").lower()

    if "application/json" in content_type:
        actual_json = test_context.response.raw_data.decode('utf-8')
        actual = json.loads(actual_json)
        expected = json.loads(content)

        assert actual == expected, f"Expected {content}, but got {actual_json}"

    else:
        raise ValueError(f"Cannot assert against unsupported content type: {content_type}")

class Request:
    def __init__(self, classname, operation_id):
        self.classname = classname
        self.operation_id = operation_id
        self.parameters = {}

def convert_to(to_type: type[T], value: str) -> any:
    if to_type == str:
        return value
    elif to_type == int:
        return int(value)
    elif to_type == float:
        return float(value)
    elif to_type == bool:
        return bool(value)
    elif to_type == uuid.UUID:
        return uuid.UUID(value)
    elif issubclass(to_type, enum.Enum):
        return to_type[value]

    raise TypeError(f"Cannot convert from str to {to_type.__name__}")